# wasm-host-bindgen

This is an experimental tool to support [WebAssembly Web IDL
Bindings][web-idl-bindings]. The specification is still a draft, but
it is important to start an implementation to reveal concrete
obstacles.

Here is the final expected flow:

  1. A program written in language _L_ (e.g. Rust) is compiled by a
     compiler _C_ (e.g. `rustc`) to WebAssembly,

  2. The compiler _C_ emits a WebAssembly module binary _M_,
     containing a custom section named `webidl-bindings`, which
     contains Web IDL Bindings with a binary representation,
     
  3. Given a WebAssembly module _M_, a ‚Äúbinding generator‚Äù _D_ is able
     to _decode_ the `webidl-bindings` custom section in order to
     generate glue code _G_ for the host _H_ (e.g. Python code if the
     host is Python),

  4. The end user interacts with a WebAssembly instance of _M_
     through the glue code _G_,
     
  5. This is how _L_ and _H_ can communicate seamlessly through
     bindings, without encoding or decoding memory data by hand.

The current state is:

  -  No compiler _C_ emits Web IDL bindings yet as part of the
     WebAssembly module. Thus we have to simulate that feature and to
     support an _encoding_ step to transform Web IDL Bindings into its
     binary representation, and to inject it into the WebAssembly module
     custom section (hint: this is the `wasm-host-bindgen encode`
     command),
     
  - The binary representation isn't defined yet. [@rustwasm][rustwasm]
    has made [a proposal][binary-representation]. This is the binary
    representation used in this experimental project,
    
  - The only host considered so far by the specification is JavaScript
    as it is part of the Web platform, and this platform is tightly
    based on Web IDL. This isn't the case for other non-Web
    hosts. Consequently, a _prelude_ must be generated too in order to
    bind Web IDL API to the host API (hint: this is the `--with-prelude`
    option),
    
  - Only the Web has a standard WebAssembly API. No other host has
    such interfaces or standards. For the sake of simplicity as part
    of the first iteration of this experimental project, we will
    consider the API provided by the [Wasmer language
    integrations][wasmer-language-integrations]: They are closed to
    the Web standard. The next iteration must obviously provide
    runtime-agnostic interfaces or standards to support
    WebAssembly. This is another project to run apart from this
    one. See the [Proposal: Non-Web Embedder
    APIs][non-web-embedder-apis] discussion.
    
Consequently, to use `wasm-host-bindgen`, one has to:

  1. [not necessary in the future] Write Web IDL Bindings by hand,

  2. [not necessary in the future] Encode the bindings into a
     WebAssembly module with `wasm-host-bindgen encode`,

  3. Decode the bindings for a specific host with `wasm-host-bindgen decode --target <host>`.

[web-idl-bindings]: https://github.com/WebAssembly/webidl-bindings
[binary-representation]: https://github.com/rustwasm/wasm-webidl-bindings/blob/master/BINARY.md
[rustwasm]: https://github.com/rustwasm/
[wasmer-language-integrations]: https://github.com/wasmerio?utf8=%E2%9C%93&q=-ext-wasm&type=public&language=
[non-web-embedder-apis]: https://github.com/WebAssembly/design/issues/1290

## Example

```sh
$ # Compile the `.wat` file to a `.wasm` binary module.
$ wat2wasm examples/hello_world.wat -o examples/hello_world.wasm

$ # Compile `wasm-host-bindgen`.
$ cargo build

$ # Insert/Encode the Web IDL bindings into the `.wasm` binary module.
$ # Usually, this step isn't necessary. It aims to be done by a
$ # compiler (e.g. `rustc`). However, right now, the WebAssembly Web IDL
$ # Bindings specification and toolchain are early drafts, making this step
$ # necessary.
$ ./target/debug/wasm-host-bindgen \
      encode \
          examples/hello_world.wasm \
          examples/hello_world.webidl

$ # Decode the Web IDL bindings (that are stored inside the WebAssembly binary module).
$ # Decoding targets Python.
$ ./target/debug/wasm-host-bindgen \
      decode \
          --target python \
          --with-prelude \
          --output examples/hello_world_bindings.py \
          examples/hello_world.bound.wasm

$ # Assuming `wasmer` is installed, it is possible to run the
$ # WebAssembly module with bindings.
$ python examples/hello_world.py
Hello, World!
```

One may ask: Why is the WebAssembly module hand-written with the WAT
format? Good question. A Web IDL Binding contains statements like
`func-binding` and `bind`. They respectively need:

  1. the index of the WebAssembly function type, and
  2. the index of the WebAssembly function.
  
Those indices are generated by the compiler that transforms the `.wat`
file to the `.wasm` file (in this case, this is a 1:1 mapping,
i.e. indices are identical), or by the compiler that transforms the
program written in language _L_ to the WebAssembly module directly (in
this case, indices are auto-generated, we have no control over
them). In the latter scenario, it is annoying to inspect the
WebAssembly module, to collect the indices, and to update the Web IDL
Binding‚Ä¶ everytime. So the solution used for the first iteration of
this experimental project, is to write the WebAssembly file by hand,
so that we know the indices, and we can hard-code them in the
bindings. Again, this issue is part of the _encoding_ step, which will
disappear in the future.

## Status

The Web IDL Bindings specification defines binding operators and
expressions.

Each status is attached to a particular host. In the following tables,
Python is represented by üêç.

The following table lists the _outgoing binding
expression_ and shows their respective implementation status:

| Target | Operator | Status | Details |
|-|-|-|-|
| üêç | `as` | not implemented | |
| üêç | `utf8-str` | partially implemented | `DOMString`, ~`USVString`~ |
| üêç | `i32-to-enum` | not implemented |
| üêç | `view` | not implemented |
| üêç | `copy` | partially implemented | `ByteString`, ~`BufferSource`~ |
| üêç | `dict` | not implemented |
| üêç | `bind-export` | not implemented |

The following table lists the _incoming binding expression_ and shows
their respective implementation status:

|Target | Operator | Status | Details |
|-|-|-|-|
| üêç | `as` | not implemented | |
| üêç | `alloc-utf8-str` | not implemented | |
| üêç | `alloc-copy` | not implemented |
| üêç | `enum-to-i32` | not implemented |
| üêç | `field` | not implemented |
| üêç | `bind-import` | not implemented |

The following table lists the _function bindings_ and shows their
respective implementation status:

| Target | Function type | Status for outgoing values | Status for incoming values | Details |
|-|-|-|-|-|
| üêç | `export` | [results] implemented | [parameters] not implemented |
| üêç | `import` | [parameters] not implemented | [results] not implemented |


The following table lists the _runtime API_ support and shows their
respective implementation status:

| Target | API | Status | Details |
|-|-|-|-|
| üêç | `bind_export` | implemented | Implementation lands in the glue code. Ideally it should be part of the runtime. |
| üêç | `bind_import` | not implemented |
